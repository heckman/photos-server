#!/bin/dash
#
#  photos-server
#
# serves photos from Photos.app

# listens on a port for a search term and returns a photo from the photos app
# if photos returns multiple photos a random one is selected
# if there are no matches a default placeholder is returned

host=127.0.0.1
port=6330

default_timeout_seconds=1

app_id=ca.heckman.photos-server
tcpserver_pid_file="${TMPDIR}${app_id}.tcpserver.pid"
temp_dir=
stdlog=/dev/stderr
image_regex='/\.(jpeg|jpg|heic)$/i' # don't match movies

this_script="$(realpath "$0")"

usage(){ echo "USAGE:

photos-server command [args]

	start [timeout]
	stop
	restart [timeout]
	status
		Commands to manage an HTTP server on port $port.

	find <query>
		Print id of random photo from a Photos.app search.

	export <id> [<destination>]
		Export a media item from Photos.app by id.

	respond [timeout]
		Respond to an HTTP request with a Photos.appmedia item,
		specified by id, or a random photo from a search.
		Do not run this from the command line.

The argument timeout, measured in seconds, specifies how long to
wait for Photos.app to return with results of a query. The default
is $(pluralized seconds "$default_timeout_seconds"). Set to 0 to disable timeout.
"; exit 69; }


main(){ local cmd="$1";shift
	case "$cmd" in
		start) start "$@" ;;
		stop) stop "$@" ;;
		restart) restart "$@" ;;
		status) status "$@" ;;
		respond) generate_http_response "$@";;
		find) get_photo_id "$@" ;;
		export) export_photo_by_id "$@" ;;
		*) usage ;;
	esac
}

start(){
	if is_running
	then
		echo "already running"
		exit 1
	else
		log "tcpserver -v -RHl0 '$host' '$port' '$this_script' respond $*"
		tcpserver -v -RHl0 "$host" "$port" "$this_script" respond "$@"&
		echo $! > "$tcpserver_pid_file"
		pause
		status
	fi
}
pause(){
	sleep 0.5
}
stop(){
	terminate_process
	pause
	status
}

restart(){
	stop
	pause
	start "$@"
}

status(){
	if is_running
	then
		echo "running (pid $(cat "$tcpserver_pid_file"))"
	else
		echo "stopped"
	fi
}

terminate_process(){
	test -f "$tcpserver_pid_file" || return
	if pkill -F "$tcpserver_pid_file" 2>/dev/null
	then
		remove_pid_file
		true
		return
	else
		printf "invalid pid in pid file: " >&2
		cat "$tcpserver_pid_file" >&2
		echo "removing pid file: $tcpserver_pid_file" >&2
		remove_pid_file
		false
		return
	fi
}

is_running(){
	if test -f "$tcpserver_pid_file"
	then
		if pgrep -F "$tcpserver_pid_file" >/dev/null
		then
			true
			return
		else
			rm "$tcpserver_pid_file"
		fi
	fi
	false
}

remove_pid_file(){
	rm "$tcpserver_pid_file"
}

get_photo_id(){ local search_term="$1" timeout_seconds="${2:-$default_timeout_seconds}"
	test -z "$search_term" && search_term="$(cat -)"
	log 'search_term=%s\n' "$search_term"
	if test "$timeout_seconds" != "0"
	then
		# shellcheck disable=SC2016
		timeoutcode='
			ObjC.import("stdlib");
    		$.system(`
				pid=$(ps -o ppid= $$)
				{
					sleep ${'"$timeout_seconds"'}
					kill $pid 2>/dev/null \
						&& echo "search timed out" >&2
				}>/dev/null &
			`)'
	else
		timeoutcode=""
	fi
	osascript -l JavaScript -e "
		$timeoutcode
		const mediaItem=Application('Photos')
			.mediaItems.byId('$search_term')
		if(mediaItem.exists()){
			mediaItem.id()
		} else {
			const matchingPhotos=Application('Photos')
				.search({for:'$search_term'})
				.filter(x=>x.filename().match($image_regex))
			if (matchingPhotos.length){
				matchingPhotos[
					Math.floor(Math.random() * matchingPhotos.length)
				].id()
			}
		}"
}

# print an id if there's a match, otherwise nothing.
export_photo_by_id(){ local id="$1" destination="${2:-.}"
	osascript -l JavaScript -e "
	const photos=Application('Photos')
	const mediaItem=Application('Photos').mediaItems.byId('$id')
	Application('Photos').export([mediaItem],{to:Path('$destination')})
"
}

make_temporary_directory(){ local photo_id="$1"
	temp_dir="${TMPDIR}${app_id}-${photo_id}"
	mkdir -p "$temp_dir"
	# shellcheck disable=SC2064 # it's a trap! (expand now)
	trap 'rm -rf "$temp_dir"' EXIT
	echo "$temp_dir"
}

get_photo_filename(){ local dir="$1"
	log "looking for file in: %s\n" "$dir"
	find "$dir" -maxdepth 1 -type f ! -name '.*' 2>/dev/null
}

generate_http_response(){
	local timeout_seconds="${1:-$default_timeout_seconds}"
	query="$(
		head -1 \
		| awk -F '[ /]' '$1=="GET" {print $3}'
	)"
	log 'query=%s\n' "$query"
	test -z "$query" && respond_with_http_error 404

	photo_id="$(get_photo_id "$query" "$timeout_seconds")" \
		|| respond_with_http_error 500
	photo_id="${photo_id%%/*}"
	log 'photo_id=%s\n' "$photo_id"
	test -z "$photo_id" && respond_with_http_error 404

	temp_dir="$(make_temporary_directory "$photo_id")"
	log 'temp_dir=%s\n' "$temp_dir"

	photo_filename="$(get_photo_filename "$temp_dir")"
	log 'photo_filename=%s\n' "$photo_filename"
	if test -z "$photo_filename"
	then
		log 'exporting photo\n'
		export_photo_by_id "$photo_id" "$temp_dir"

		photo_filename="$(get_photo_filename "$temp_dir")"
		log 'photo_filename=%s\n' "$photo_filename"
		test -z "$photo_filename" && respond_with_http_error 404
	fi

	respond_with_photo "$photo_filename"
}

get_photo_file(){ local dir="$1"
	photo_filename="$(photo_filename "$dir")"
	if test -z "$photo_filename"
	then
		photo_filename="$(photo_filename "$dir")"
	fi
	echo "$photo_filename"

}

respond_with_photo(){ filename=$1
	log 'responding with photo: %s\n' "$(basename "$filename")"

	file_size="$(stat -f'%z' "$photo_filename")"
	file_type="$(file -b --mime-type "$photo_filename")"

	print_http_image_header \
		"200 OK" "$photo_filename" "$file_size" "$file_type"
	echo
	cat "$photo_filename"

}
respond_with_http_error(){ status="$1"
	case "$status" in
	404)
		status="404 Not Found"
		filename="missing.svg"
		image_content="$missing_svg"
		;;
	*)
		status="500 Internal Server Error"
		filename="error.svg"
		image_content="$error_svg"
		;;
	esac
	file_size=${#image_content}
	print_http_image_header \
		"$status" "$filename" "$file_size" "svg+xml"
	echo
	echo "$image_content"
	exit 0
}

print_http_image_header(){
	status="$1"
	filename="$2"
	file_size="$3"
	content_type="$4"
	echo "HTTP/1.1 $status"
	echo "Content-Disposition: inline; filename=\"$(basename "$filename")\""
	echo "Content-Type: $content_type"
	echo "Content-Length: $file_size"
}

missing_svg='<?xml version="1.0" encoding="UTF-8"?>
<!-- old school pixellated netscape broken image icon -->
<!--
  source: https://gist.github.com/diachedelic/cbb7fdd2271afa52435b7d4185e6a4ad
  accessed: 2024-02-12
-->
<svg viewBox="0 0 14 16" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <g id="borders-and-backgrounds">
    <path d="M0,0 L10,0 L10,1 L1,1 L1,15 L2,15 L2,16 L0,16 Z" fill="black"></path>
    <path d="M10,4 l4,0 l0,3 l-1,0 l0,-2 l-3,0 Z" fill="black"></path>
    <path d="M14,16 l0,-6 l-1,0 l0,5 l-5,0 l0,1 Z" fill="black"></path>
    <path d="M12,14 l0,-3 l-1,0 l0,2 l-2,0 l0,1 Z" fill="#bcbcc3"></path>
    <path d="M10,0 l1,0 l0,1 l1,0 l0,1 l1,0 l0,1 l1,0 l0,1 l-1,0 l0,-1 l-1,0 l0,-1 l-1,0 l0,2 l-1,0 Z" fill="#878787">
    </path>
    <path d="M2,2 l8,0 l0,3 l2,0 l0,2 l-4,0 l0,5 l-2,0 l0,1 l-2,0 l0,1 l-2,0 Z" fill="#bcbcc3"></path>
  </g>
  <g id="lefteye">
    <path d="M5,3 l2,0 l0,3 l-3,0 l0,-2 l1,0 l0,1 l1,0 l0,-1 l-1,0 Z" fill="#00891e"></path>
    <path d="M5,4 l1,0 l0,1 l-1,0 Z" fill="#00f248"></path>
    <path d="M7,4 l1,0 l0,2 l-1,0 l0,1 l-2,0 l0,-1 l2,0 Z" fill="black"></path>
  </g>
  <g id="righteye">
    <path d="M8,7 l3,0 l0,2 l-1,0 l0,-1 l-1,0 l0,1 l1,0 l0,1 l-2,0 Z" fill="#0064fb"></path>
    <path d="M9,8 l1,0 l0,1 l-1,0 Z" fill="#00fbfe"></path>
    <path d="M10,9 l1,0 l0,1 l-1,0 Z" fill="#003293"></path>
    <path d="M11,7 l1,0 l0,2 l-1,0 Z" fill="black"></path>
    <path d="M8,10 l2,0 l0,1 l-2,0 Z" fill="black"></path>
  </g>
  <g id="mouth">
    <path d="M3,8 l1,0 l0,1 l1,0 l0,1 l1,0 l0,1 l1,0 l0,1 l-1,0 l0,-1 l-1,0 l0,-1 l-1,0 l0,-1 l-1,0 Z" fill="#ff3900">
    </path>
    <path d="M3,9 l1,0 l0,1 l1,0 l0,1 l1,0 l0,1 l-3,0 Z" fill="#f73ae1"></path>
    <path d="M3,12 l3,0 l0,1 l-3,0 Z" fill="black"></path>
  </g>
</svg>
'
error_svg='<?xml version="1.0" encoding="UTF-8"?>
<!--
hand-coded and shaded svg by Erik Ben Heckman https://erik.heckman.ca
of the original "Sad Mac" icon by Susan Kare https://kareprints.com
-->
<svg viewBox="0 0 37 37" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <g id="shading">
    <path id="mask" fill="#f4f4f4" d="
    M6,4 h25 v26 h-25 z M7,3 h23 v32 h-23 zM8,2 h 21 v 2 h-21 z"></path>
    <path id="screen" fill="#fafafa" d="
    M10,6 h17 v14 h-17 Z"></path>
    <path id="plinth" fill="#ddd" d="
    M8,31 h21 v 3 h-21 Z"></path>
  </g>
  <path id="lines" fill-rule="evenodd" fill="black" d="
    M6,4 h25 v26 h-25 z M7,3 h23 v32 h-23 z M8,2 h 21 v 2 h-21 z M8,31 h21 v 3 h-21 Z
    M10,5 h17 v16 h-17 z M9,6 h19 v14 h-19 Z
    M13,9 h1 v3 h-1 v-1 h3 v1 h-1 v-3 h1 v1 h-3 Z
    M21,9 h1 v3 h-1 v-1 h3 v1 h-1 v-3 h1 v1 h-3 Z
    M16,13 h1 v2 h2 v-2 h1 v1 h-4 Z
    M16,16 h5 v2 h3 v1 h-1 v-2 h-8 v 1 h 1 Z
    M9,26 h2 v1 h-2 Z
    M21,25 h6 v1 h-6 Z"></path>
</svg>
'

# shellcheck disable=SC2059
log(){ if test -z "$1"; then cat - >$stdlog; else printf "$@" >$stdlog; fi; }

pluralized(){ local term="$1" number="$2"
	if test "$number" = "1"
	then
		printf '%d second' "$number"
	else
		printf '%d seconds' "$number"
	fi
}

main "$@"

