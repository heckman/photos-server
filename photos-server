#!/bin/dash
#
#  photos-server
#
# serves photos from Photos.app

# Listens on a port for a query, and forwards it to Apple Photos.
# If the query is the id of a media item in the Photos library,
# that media item is returned. Otherwise Photos performs a search,
# the responses are limited to photos, and one of the results,
# randomly selected, is returned.

host=127.0.0.1
port=6330

default_timeout_seconds=1

app_id=ca.heckman.photos-server
tcpserver_pid_file="${TMPDIR}${app_id}.tcpserver.pid"
stdlog=/dev/stderr

this_script="$(realpath "$0")" #should be good enough for now
this_dir="$(dirname "$this_script")"
tcpserver_options="-v -RHl0" # this will undergo whitespace splitting

bin_find_photo="$this_dir/bin/get-photo-id"
bin_export_photo="$this_dir/bin/export-photos-by-id"


usage(){ echo "USAGE:

photos-server command [args]

    start [timeout]
    stop
    restart [timeout]
    status
        Commands to manage an HTTP server on port $port.

    respond [timeout]
        Reads an HTTP request from stdin and responds with an HTTP
        resonse comprised of response headers and binary image
        data. Do not run this from the command line.

The argument timeout, measured in seconds, specifies how long to
wait for Photos.app to return with results of a query. The default
is $(pluralized second "$default_timeout_seconds"). Set to 0 to disable timeout.
"; exit 69; }


main(){ local cmd="$1"; shift
	case "$cmd" in
		start) start "$@" ;;
		stop) stop "$@" ;;
		restart) restart "$@" ;;
		status) status "$@" ;;
		respond) respond "$@" ;;
		*) usage ;;
	esac
}


#### server control

start(){
	if is_running
	then
		echo "already running"
	else
		# shellcheck disable=SC2086
		tcpserver $tcpserver_options $host $port "$this_script" respond "$@"&
		echo $! > "$tcpserver_pid_file"
		pause
		status
	fi
}
pause(){ sleep 0.5; }
stop(){ terminate_process; pause; status; }
restart(){ stop; pause; start "$@";}
status(){
	if is_running
	then
		echo "running (pid $(cat "$tcpserver_pid_file"))"
	else
		echo "stopped"
	fi
}

terminate_process(){
	test -f "$tcpserver_pid_file" || return
	if pkill -F "$tcpserver_pid_file" 2>/dev/null
	then
		rm "$tcpserver_pid_file"
		true
		return
	else
		printf "invalid pid in pid file: " >&2
		cat "$tcpserver_pid_file" >&2
		echo "removing pid file: $tcpserver_pid_file" >&2
		rm "$tcpserver_pid_file"
		false
		return
	fi
}

is_running(){
	if test -f "$tcpserver_pid_file"
	then
		if pgrep -F "$tcpserver_pid_file" >/dev/null
		then
			true
			return
		else
			rm "$tcpserver_pid_file"
		fi
	fi
	false
}


#### response handler

respond(){
	local timeout_seconds="${1:-$default_timeout_seconds}"

	urlencoded_query="$(head -1 | awk -F '[ /]+' '$1=="GET" {print $2}')"
	log '\n'
	query="$(osascript -l JavaScript -e '
		ObjC.unwrap($.NSURL.URLWithString("'"$urlencoded_query"'").path)'
		)" # urldecoded
	log 'Query: %s\n' "$query"
	test -z "$query" && respond_with_404_error


	photo_id="$(
		"$bin_find_photo" --timeout "$timeout_seconds" "$query"
	)" || {
		test $? -lt 128 && {
			log 'No query results.\n'
			respond_with_404_error
		}
		log 'Timeout occurred searching for query.\n'
		respond_with_500_error
	}
	log 'Photo ID: %s\n' "$photo_id"

	temp_dir="$(make_temporary_directory "$photo_id")"
	log 'Temporary directory: %s\n' "$temp_dir"

	photo_filename="$(
		get_photo_filename "$temp_dir"
	)" || {
		log "File not found.\n"
		log "Exporting photo...\n"
		"$bin_export_photo" "$photo_id" "$temp_dir" \
		&& photo_filename="$(get_photo_filename "$temp_dir")"
	} || {
		log "Problem exporting photo\n"
		respond_with_500_error
	}
	log "Found file: %s\n" "$photo_filename"

	log "Responding with file.\n"
	respond_with_image_file "200 OK" "$photo_filename"
	exit 0
}
respond_with_image_file(){
	local status="$1" filename="$2"
	file_size="$(stat -f'%z' "$filename")"
	file_type="$(file -b --mime-type "$filename")"
	print_http_image_header \
		"$status" "$filename" "$file_size" "$file_type"
	echo
	cat "$filename"
}
respond_with_image_content(){
	local status="$1" filename="$2" file_type="$3" image_content="$4"
	file_size=${#image_content}
	print_http_image_header \
		"$status" "$filename" "$file_size" "$file_type"
	echo
	echo -n "$image_content"
}
respond_with_404_error(){
	log "Responding with error code 404.\n"
	respond_with_image_content \
		"404 Not Found" \
		"missing.svg" \
		"svg+xml" \
		"$missing_svg"
	exit 104
}
respond_with_500_error(){
	log "Responding with error code 500.\n"
	respond_with_image_content \
		"500 Internal Server Error" \
		"error.svg" \
		"svg+xml" \
		"$error_svg"
	exit 200
}
print_http_image_header(){
	status="$1"
	filename="$2"
	file_size="$3"
	content_type="$4"
	echo "HTTP/1.1 $status"
	echo "Content-Disposition: inline; filename=\"$(basename "$filename")\""
	echo "Content-Type: $content_type"
	echo "Content-Length: $file_size"
}

make_temporary_directory(){ local photo_id="$1"
	temp_dir="${TMPDIR}${app_id}-${photo_id}"
	mkdir -p "$temp_dir"
	# shellcheck disable=SC2064 # it's a trap! (expand now)
	trap 'rm -rf "$temp_dir"' EXIT
	echo "$temp_dir"
}

get_photo_filename(){ local dir="$1"
	find "$dir" -maxdepth 1 -type f ! -name '.*' 2>/dev/null | grep -F ''
}

missing_svg='<?xml version="1.0" encoding="UTF-8"?>
<!-- old school pixellated netscape broken image icon -->
<!--
  source: https://gist.github.com/diachedelic/cbb7fdd2271afa52435b7d4185e6a4ad
  accessed: 2024-02-12
-->
<svg viewBox="0 0 14 16" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <g id="borders-and-backgrounds">
    <path d="M0,0 L10,0 L10,1 L1,1 L1,15 L2,15 L2,16 L0,16 Z" fill="black"></path>
    <path d="M10,4 l4,0 l0,3 l-1,0 l0,-2 l-3,0 Z" fill="black"></path>
    <path d="M14,16 l0,-6 l-1,0 l0,5 l-5,0 l0,1 Z" fill="black"></path>
    <path d="M12,14 l0,-3 l-1,0 l0,2 l-2,0 l0,1 Z" fill="#bcbcc3"></path>
    <path d="M10,0 l1,0 l0,1 l1,0 l0,1 l1,0 l0,1 l1,0 l0,1 l-1,0 l0,-1 l-1,0 l0,-1 l-1,0 l0,2 l-1,0 Z" fill="#878787">
    </path>
    <path d="M2,2 l8,0 l0,3 l2,0 l0,2 l-4,0 l0,5 l-2,0 l0,1 l-2,0 l0,1 l-2,0 Z" fill="#bcbcc3"></path>
  </g>
  <g id="lefteye">
    <path d="M5,3 l2,0 l0,3 l-3,0 l0,-2 l1,0 l0,1 l1,0 l0,-1 l-1,0 Z" fill="#00891e"></path>
    <path d="M5,4 l1,0 l0,1 l-1,0 Z" fill="#00f248"></path>
    <path d="M7,4 l1,0 l0,2 l-1,0 l0,1 l-2,0 l0,-1 l2,0 Z" fill="black"></path>
  </g>
  <g id="righteye">
    <path d="M8,7 l3,0 l0,2 l-1,0 l0,-1 l-1,0 l0,1 l1,0 l0,1 l-2,0 Z" fill="#0064fb"></path>
    <path d="M9,8 l1,0 l0,1 l-1,0 Z" fill="#00fbfe"></path>
    <path d="M10,9 l1,0 l0,1 l-1,0 Z" fill="#003293"></path>
    <path d="M11,7 l1,0 l0,2 l-1,0 Z" fill="black"></path>
    <path d="M8,10 l2,0 l0,1 l-2,0 Z" fill="black"></path>
  </g>
  <g id="mouth">
    <path d="M3,8 l1,0 l0,1 l1,0 l0,1 l1,0 l0,1 l1,0 l0,1 l-1,0 l0,-1 l-1,0 l0,-1 l-1,0 l0,-1 l-1,0 Z" fill="#ff3900">
    </path>
    <path d="M3,9 l1,0 l0,1 l1,0 l0,1 l1,0 l0,1 l-3,0 Z" fill="#f73ae1"></path>
    <path d="M3,12 l3,0 l0,1 l-3,0 Z" fill="black"></path>
  </g>
</svg>
'
error_svg='<?xml version="1.0" encoding="UTF-8"?>
<!--
hand-coded and shaded svg by Erik Ben Heckman https://erik.heckman.ca
of the original "Sad Mac" icon by Susan Kare https://kareprints.com
-->
<svg viewBox="0 0 37 37" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <g id="shading">
    <path id="mask" fill="#f4f4f4" d="
    M6,4 h25 v26 h-25 z M7,3 h23 v32 h-23 zM8,2 h 21 v 2 h-21 z"></path>
    <path id="screen" fill="#fafafa" d="
    M10,6 h17 v14 h-17 Z"></path>
    <path id="plinth" fill="#ddd" d="
    M8,31 h21 v 3 h-21 Z"></path>
  </g>
  <path id="lines" fill-rule="evenodd" fill="black" d="
    M6,4 h25 v26 h-25 z M7,3 h23 v32 h-23 z M8,2 h 21 v 2 h-21 z M8,31 h21 v 3 h-21 Z
    M10,5 h17 v16 h-17 z M9,6 h19 v14 h-19 Z
    M13,9 h1 v3 h-1 v-1 h3 v1 h-1 v-3 h1 v1 h-3 Z
    M21,9 h1 v3 h-1 v-1 h3 v1 h-1 v-3 h1 v1 h-3 Z
    M16,13 h1 v2 h2 v-2 h1 v1 h-4 Z
    M16,16 h5 v2 h3 v1 h-1 v-2 h-8 v 1 h 1 Z
    M9,26 h2 v1 h-2 Z
    M21,25 h6 v1 h-6 Z"></path>
</svg>
'

# shellcheck disable=SC2059
log(){ if test -z "$1"; then cat - >$stdlog; else printf -- "-> $@" >$stdlog; fi; }

pluralized(){ local term="$1" number="$2"
	if test "$number" = "1"
	then
		printf '%d %s' "$number" "$term"
	else
		printf '%d %ss' "$number" "$term"
	fi
}

main "$@"

