#!/usr/bin/osascript -l JavaScript
// SPDX-FileCopyrightText: 2024 Erik Ben Heckman
// SPDX-PackageDownloadLocation: git://github.com/heckman/photos-server
// SPDX-License-Identifier: GPL-3.0-only

/**
 *
 * get-photo-id
 *
 * Find a media item in Photos.app by id or query.
 *
 *
 * Copyright (c) 2024 by Erik Ben Heckman <erik@heckman.ca> ("ERIK")
 *
 * Permission to use, copy, modify, and/or distribute this software for
 * any purpose with or without fee is hereby granted, provided that the
 * above copyright notice and this permission notice appear in all
 * copies.
 *
 * THE SOFTWARE IS PROVIDED “AS IS” AND ERIK DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL ERIK BE LIABLE FOR ANY
 * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
 * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/**
 * Usage:
 *
 * get-photo-id [--id|--search [--all]] [--timeout <seconds>] <id/query>
 */

function run(arguments) {
  try {
    [[query, ...ignored], options] = parse_options(arguments, {
      id: false, // true = fail if the query does not match an id
      search: false, // true = search only: do not check for id match first
      all: false, // false = only return one id from the resultant search
      full: false, // false = only return part of id up until first slash
      timeout: 0, // abort after this many seconds, 0 = never
      filter: "\\.(jpeg|jpg|heic)$", // when searching, only return
      // media items whose filename matches this case-insensitive regular
      // expression. Use a dot or an empty string to match everything.
    });
    if (!query) throw new Error("No query specified.", { cause: 64 });

    set_timeout(
      options.timeout,
      `Search timed out after ${options.timeout} second${
        options.timeout == 1 ? "" : "s"
      }.`
    ); // to abort overly-broad searches

    var media_items = [];
    var media_item;

    if (
      !options.search && // which would force search-only
      looks_like_an_id(query) &&
      (media_item = get_item_by_id(query)) &&
      media_item.exists()
    ) {
      return get_id(media_item, options.full);
    } else if (!options.id) {
      // which would force id-only
      media_items = get_items_by_search(
        query,
        new RegExp(options.filter, "i")
      );
      if (!media_items.length) {
        throw new Error("No items found.");
      } else if (!options.all) {
        return get_id(random_member_of(media_items), options.full);
      } else {
        return media_items
          .map((media_item) => get_id(media_item, options.full))
          .join("\n");
      }
    } else {
      throw new Error("ID not found.");
    }
  } catch (e) {
    ObjC.import("stdlib");
    console.log(e.message);
    $.exit(Number.isInteger(e.cause) ? e.cause : 1);
  }
}

function get_id(media_item, full) {
  return full ? media_item.id() : media_item.id().replace(/\/.*$/, "");
}

// returns true if the argument follows the pattern of a valid id
function looks_like_an_id(possible_id) {
  return /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}/.test(
    possible_id
  );
}

// returns either a valid Photos.app media item or false if none is found
function get_item_by_id(possible_id) {
  const media_item = Application("Photos").mediaItems.byId(possible_id);
  if (!media_item.exists) false;
  return media_item;
}

// query -> [ Photos.app media items ] or [] if no matches
function get_items_by_search(query, pattern = "") {
  return Application("Photos")
    .search({ for: query })
    .filter((item) => item.filename().match(pattern));
}

// array -> random item in array
function random_member_of(an_array) {
  return an_array[Math.floor(Math.random() * an_array.length)];
}

// arguments, default_options -> [ arguments, options ]
// separates options (long form only) from arguments and validates them
function parse_options(arguments, options = {}) {
  var argument;
  while ((argument = arguments.shift())) {
    if (argument.charAt(0) != "-") {
      arguments.unshift(argument);
      break;
    }
    let option = argument.replace(/^--/, "");
    if (!option) break; // argument was --
    if (options[option] == undefined)
      throw new Error(`Unknown option: '${argument}'.`);
    if (options[option] === true) options[option] = false;
    else if (options[option] === false) options[option] = true;
    else {
      // expects a value
      let value = arguments.shift();
      if (value === undefined || value == "--")
        throw new Error(`Missing value for option: '${option}'.`);
      options[option] = value;
    }
  }
  return [arguments, options];
}

function set_timeout(seconds, message = "Timed out.") {
  if (0 < seconds) {
    ObjC.import("stdlib");
    $.system(`
    pid=$(ps -o ppid= $$)
    {
      sleep ${seconds}
      kill $pid 2>/dev/null && echo "${message}" >&2
    }>/dev/null &
  `);
  }
}
