#!/usr/bin/osascript -l JavaScript
/*
  Find a media item in Photos.app by id or query.


  get-photo-id [--id|--search [--all]] [--timeout <seconds>] <id/query>

*/
function run(arguments) {
  [[query, ...ignored], options] = parse_options(arguments, {
    id: false, // true = fail if the query does not match an id
    search: false, // true = search only: do not check for id match first
    all: false, // false = only return one id from the resultant search
    full: false, // false = only return part of id up until first slash
    timeout: 0, // abort after this many seconds, 0 = never
    filter: "\\.(jpeg|jpg|heic)$", // when searching, only return
    // media items whose filename matches this case-insensitive regular
    // expression. Use a dot or an empty string to match everything.
  });
  if (!query) throw "no query specified";

  set_timeout(options.timeout); // to abort overly-broad searches

  var media_items = [];
  var media_item;

  if (
    !options.search &&
    looks_like_an_id(query) &&
    (media_item = get_item_by_id(query))
  ) {
    return get_id(media_item, options.full);
  } else if (!options.id) {
    media_items = get_items_by_search(
      query,
      new RegExp(options.filter, "i")
    );
    if (!media_items.length) {
      return;
    } else if (!options.all) {
      return get_id(random_member_of(media_items), options.full);
    } else {
      return media_items
        .map((media_item) => get_id(media_item, options.full))
        .join("\n");
    }
  }
  return;
}

function get_id(media_item, full) {
  return full ? media_item.id() : media_item.id().replace(/\/.*$/, "");
}

// returns true if the argument follows the pattern of a valid id
function looks_like_an_id(possible_id) {
  return /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}/.test(
    possible_id
  );
}

// returns either a valid Photos.app media item or false if none is found
function get_item_by_id(possible_id) {
  const media_item = Application("Photos").mediaItems.byId(possible_id);
  if (!media_item.exists) false;
  return media_item;
}

// query -> [ Photos.app media items ] or [] if no matches
function get_items_by_search(query, pattern = "") {
  return Application("Photos")
    .search({ for: query })
    .filter((item) => item.filename().match(pattern));
}

// array -> random item in array
function random_member_of(an_array) {
  return an_array[Math.floor(Math.random() * an_array.length)];
}

// arguments, default_options -> [ arguments, options ]
// separates options (long form only) from arguments and validates them
function parse_options(arguments, options = {}) {
  var argument;
  while ((argument = arguments.shift())) {
    if (argument.charAt(0) != "-") {
      arguments.unshift(argument);
      break;
    }
    let option = argument.replace(/^--/, "");
    if (!option) break; // argument was --
    if (options[option] == undefined)
      throw `unknown option: ${argument}`;
    if (options[option] === true) options[option] = false;
    else if (options[option] === false) options[option] = true;
    else {
      // expects a value
      let value = arguments.shift();
      if (value === undefined || value == "--")
        throw `missing value for option: ${option}`;
      options[option] = value;
    }
  }
  return [arguments, options];
}

function set_timeout(seconds) {
  if (0 < seconds) {
    ObjC.import("stdlib");
    $.system(`
    pid=$(ps -o ppid= $$)
    {
      sleep ${seconds}
      kill $pid 2>/dev/null
    }&
  `);
  }
}
