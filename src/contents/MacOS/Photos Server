#!/usr/bin/osascript -l JavaScript
/*
 *  Handler
 *
 *  Handles both http requests and url-opening events.
 *
 */
const tempDirTemplate = "ca.heckman.PhotosServer.exported-media-item.";

const fileManager = $.NSFileManager.defaultManager;
const photos = Application("Photos");

const currentApp = Application.currentApplication();
currentApp.includeStandardAdditions = true;
const doShellScript = (script) => currentApp.doShellScript(script);

const alert = (message) => log("alert", message); // programming error
const error = (message) => log("err", message); // 500, 504
const notice = (message) => log("notice", message); // 404
const info = (message) => log("info", message); // 200
const debug = (message) => log("debug", message); // internal state

const log = (level, message) =>
	$.NSFileHandle.fileHandleWithStandardError.writeData(
		$.NSString.alloc
			.initWithString(`${level}:Handler: ${message}\n`)
			.dataUsingEncoding($.NSUTF8StringEncoding),
	);

function run(args) {
	if (args[0]) {
		debug("opening: " + args[0]);
		return withIdentifier(parseUrlPath(args[0])[0], (item) => {
			photos.spotlight(item);
			photos.activate();
		});
	}
	debug("args[0]: " + args[0]);
	const tempDir = createTemporaryDirectory(tempDirTemplate);
	if (tempDir) {
		try {
			handle_http_request(slurpStdin(), tempDir);
		} catch (e) {
			// this shouldn't happen, so if it does, log all we have!
			alert(JSON.stringify(e, Object.getOwnPropertyNames(e), 4));
			reply500();
		} finally {
			deleteDirectory(tempDir);
		}
	} else {
		alert("failed to create temporary directory");
		reply500();
	}
	return true;
}

const parseUrlPath = (urlPath) => {
	const pathComponents = urlPath?.split("/")?.slice(1); // drop the initial /;
	return [
		pathComponents?.at(0) || "", // identifier
		pathComponents?.at(-1) || pathComponents?.at(-2) || "", // basename
	];
};

const handle_http_request = (stdin, tempDir) => {
	// debug("stdin: " + stdin);
	const request = stdin.split("\n").at(0) || "";
	info("request: " + request);
	const urlPath = request?.split(" ")?.at(1); // second word
	const [identifier, basename] = parseUrlPath(urlPath);

	debug("identifier: " + identifier);
	debug("basename: " + basename);

	if (!identifier) {
		notice("no identifier in request");
		return reply404();
	}

	// returns false if the item is not found,
	// but we'll just check if a file was exported
	withIdentifier(identifier, (item) => {
		photos.export([item], {
			to: Path(tempDir),
			usingOriginals: false,
		});
	});
	const exportedFilename = directoryContents(tempDir)?.at(0);

	if (!exportedFilename) {
		notice(`no file exported for '${identifier}'`);
		return reply404();
	}

	const filename =
		basename + "." + exportedFilename.split(".").at(-1);
	const filepath = tempDir + "/" + exportedFilename;
	info(`serving '${identifier}' as '${filename}'`);
	return reply(
		[
			"HTTP/1.1 200 OK",
			`Content-Type: ${mimeType(filepath)}`,
			`Content-Length: ${fileSize(filepath)}`,
			`Content-Disposition: inline; filename=${filename}`,
		],
		"",
		filepath,
	);
};

// run a callback withthea media item selected on the basis of identifier,
// which can be either a UUID or a search query
//
// return true if the callback finished before the timeout,
// false otherwise
function withIdentifier(identifier, callback) {
	try {
		// this will fail fast, so no timeout is necessary
		callback(photos.mediaItems.byId(identifier));
		debug("Selected by UUID: " + identifier);
		return true;
	} catch {
		try {
			// this might take longer, so limit its time available
			const query = decodeQuery(identifier);
			callback(photos.search({ for: query })[0]);
			debug("Found with query: " + query);
			return true;
		} catch (e) {
			return false;
		}
	}
}

// decode a string to be used as a query
// by replacing certain symbols with spaces
const decodeQuery = (query) => {
	return query?.replace(/[+.~]/g, " ");
};

const slurpStdin = () =>
	$.NSString.alloc.initWithDataEncoding(
		$.NSFileHandle.fileHandleWithStandardInput.availableData,
		$.NSUTF8StringEncoding,
	).js;

const createDirectory = (path) =>
	fileManager.createDirectoryAtPathWithIntermediateDirectoriesAttributesError(
		path,
		true,
		$.nil,
		$.nil,
	)
		? path
		: null;

// returning boolean version
const deleteDirectory = (directory) =>
	fileManager.removeItemAtPathError(directory, $.nil);

const createTemporaryDirectory = (template = "") =>
	createDirectory(
		$.NSTemporaryDirectory().js +
			template +
			$.NSUUID.UUID.UUIDString.js,
	);

const directoryContents = (directory) =>
	((files) =>
		files && !files.isNil() ? ObjC.deepUnwrap(files) : null)(
		fileManager.contentsOfDirectoryAtPathError(directory, $.nil),
	);

const mimeType = (filePath) =>
	doShellScript(
		`file -b --mime-type '${filePath.replace(/\'/g, "'\\''")}' | grep -v '^cannot'`,
	) || null;

const fileSize = (filePath) =>
	((attributes) =>
		!attributes.isNil()
			? attributes.objectForKey($.NSFileSize).js
			: null)(
		fileManager.attributesOfItemAtPathError(filePath, $.nil),
	);

const reply = (headers, text, filePath = null) => {
	const stringContent = headers.join("\r\n") + "\r\n\r\n" + text;
	const stdOut = $.NSFileHandle.fileHandleWithStandardOutput;
	stdOut.writeData(
		$.NSString.alloc
			.initWithString(String(stringContent))
			.dataUsingEncoding($.NSUTF8StringEncoding),
	);
	if (filePath)
		stdOut.writeData($.NSData.dataWithContentsOfFile(filePath));
};

const reply200 = (filepath, filename) =>
	reply(
		[
			"HTTP/1.1 200 OK",
			`Content-Type: ${fileType(filepath)}`,
			`Content-Length: ${fileSize(filepath)}`,
			`Content-Disposition: inline; filename=${filename || filepath.split("/").at(-1)}`,
		],
		"",
		filepath,
	);

const replySvg = (responseCode, svg) =>
	reply(
		[
			"HTTP/1.1 " + responseCode,
			"Content-Type: image/svg+xml",
			"Content-Length: " + svg.length,
		],
		svg,
	);

const reply404 = () =>
	replySvg(
		"404 Not Found",
		`<?xml version="1.0" encoding="UTF-8"?>
<!-- old school pixellated netscape broken image icon -->
<!--
  icon created for Netscape Navigator by Marsh Chamberlin (https://dataglyph.com)
  SVG hand-coded by github user diachedelic (https://gist.github.com/diachedelic)
  source: https://gist.github.com/diachedelic/cbb7fdd2271afa52435b7d4185e6a4ad
  accessed: 2024-02-12
-->
<svg viewBox="0 0 14 16" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <g id="borders-and-backgrounds">
    <path d="M0,0 L10,0 L10,1 L1,1 L1,15 L2,15 L2,16 L0,16 Z" fill="black"></path>
    <path d="M10,4 l4,0 l0,3 l-1,0 l0,-2 l-3,0 Z" fill="black"></path>
    <path d="M14,16 l0,-6 l-1,0 l0,5 l-5,0 l0,1 Z" fill="black"></path>
    <path d="M12,14 l0,-3 l-1,0 l0,2 l-2,0 l0,1 Z" fill="#bcbcc3"></path>
    <path d="M10,0 l1,0 l0,1 l1,0 l0,1 l1,0 l0,1 l1,0 l0,1 l-1,0 l0,-1 l-1,0 l0,-1 l-1,0 l0,2 l-1,0 Z" fill="#878787">
    </path>
    <path d="M2,2 l8,0 l0,3 l2,0 l0,2 l-4,0 l0,5 l-2,0 l0,1 l-2,0 l0,1 l-2,0 Z" fill="#bcbcc3"></path>
  </g>
  <g id="lefteye">
    <path d="M5,3 l2,0 l0,3 l-3,0 l0,-2 l1,0 l0,1 l1,0 l0,-1 l-1,0 Z" fill="#00891e"></path>
    <path d="M5,4 l1,0 l0,1 l-1,0 Z" fill="#00f248"></path>
    <path d="M7,4 l1,0 l0,2 l-1,0 l0,1 l-2,0 l0,-1 l2,0 Z" fill="black"></path>
  </g>
  <g id="righteye">
    <path d="M8,7 l3,0 l0,2 l-1,0 l0,-1 l-1,0 l0,1 l1,0 l0,1 l-2,0 Z" fill="#0064fb"></path>
    <path d="M9,8 l1,0 l0,1 l-1,0 Z" fill="#00fbfe"></path>
    <path d="M10,9 l1,0 l0,1 l-1,0 Z" fill="#003293"></path>
    <path d="M11,7 l1,0 l0,2 l-1,0 Z" fill="black"></path>
    <path d="M8,10 l2,0 l0,1 l-2,0 Z" fill="black"></path>
  </g>
  <g id="mouth">
    <path d="M3,8 l1,0 l0,1 l1,0 l0,1 l1,0 l0,1 l1,0 l0,1 l-1,0 l0,-1 l-1,0 l0,-1 l-1,0 l0,-1 l-1,0 Z" fill="#ff3900">
    </path>
    <path d="M3,9 l1,0 l0,1 l1,0 l0,1 l1,0 l0,1 l-3,0 Z" fill="#f73ae1"></path>
    <path d="M3,12 l3,0 l0,1 l-3,0 Z" fill="black"></path>
  </g>
</svg>`,
	);
const reply500 = () =>
	replySvg(
		"500 Internal Server Error",
		`<?xml version="1.0" encoding="UTF-8"?>
<!--
The "Sad Mac" icon was created for Apple Inc. by Susan Kare https://kareprints.com
The SVG was hand-coded Erik Ben Heckman https://erik.heckman.ca
and can be found embedded in the code for https://github.com/heckman/photos-server
-->
<svg viewBox="0 0 37 37" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path id="mask" fill="#ffffff" d="
    M6,4 h25 v26 h-25 z M7,3 h23 v32 h-23 zM8,2 h 21 v 2 h-21 z"></path>
  <path id="lines" fill-rule="evenodd" fill="black" d="
    M6,4 h25 v26 h-25 z M7,3 h23 v32 h-23 z M8,2 h 21 v 2 h-21 z M8,31 h21 v 3 h-21 Z
    M10,5 h17 v16 h-17 z M9,6 h19 v14 h-19 Z
    M13,9 h1 v3 h-1 v-1 h3 v1 h-1 v-3 h1 v1 h-3 Z
    M21,9 h1 v3 h-1 v-1 h3 v1 h-1 v-3 h1 v1 h-3 Z
    M16,13 h1 v2 h2 v-2 h1 v1 h-4 Z
    M16,16 h5 v2 h3 v1 h-1 v-2 h-8 v 1 h 1 Z
    M9,26 h2 v1 h-2 Z
    M21,25 h6 v1 h-6 Z"></path>
</svg>`,
	);
const reply504 = () =>
	replySvg(
		"504 Gateway Timeout",
		`<?xml version="1.0" encoding="UTF-8"?>
<!--
The "Watch" cursor was created for Apple Inc. by Susan Kare https://kareprints.com
The SVG was hand-coded Erik Ben Heckman https://erik.heckman.ca who added the exclaimation
point and can be found embedded in the code for https://github.com/heckman/photos-server
-->
<svg viewBox="-2 -6 30 30" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <rect id="face" x="5" y="5" width="8" height="8" fill="white" />
  <path id="watch" fill-rule="evenodd" fill="black" d="
    M 6 1 h 6 v 16 h -6 Z
    M 4 6 h 10 v 6 h -10 Z
    M 5 5 h 8 v 8 h -8 Z
    M 6 6 h 6 v 6 h -6 Z
    M 14 8 h 1 v 2 h -1 Z
    M 9 6 h 1 v 4 h -3 v -1 h 2 Z
  "></path>
  <path id="bang" fill-rule=" evenodd" fill="#eb161e" d="
    M 18 1 v16 h 3 v -4 h -3 v 1 h 3 v -13 Z
  "></path>"
</svg>`,
	);

function runWithTimeout(taskFunction, timeoutMs) {
	let finished = false;
	let result = null;

	// Start your task
	const taskThread = $.NSThread.alloc.initWithTargetSelectorObject(
		$.NSBlockOperation.blockOperationWithBlock(() => {
			result = taskFunction();
			finished = true;
		}),
		"main",
		null,
	);

	taskThread.start;

	// Use NSRunLoop to wait until 'finished' is true or timeout is reached
	const limitDate = $.NSDate.dateWithTimeIntervalSinceNow(
		timeoutMs / 1000,
	);
	while (
		!finished &&
		$.NSRunLoop.currentRunLoop.runModeBeforeDate(
			"NSDefaultRunLoopMode",
			limitDate,
		)
	) {
		if ($.NSDate.date.compare(limitDate) == $.NSOrderedDescending)
			break;
	}

	if (!finished) {
		throw new Error("Task timed out");
	}
	return result;
}
