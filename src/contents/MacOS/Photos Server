#!/bin/dash
# Copyright (c) 2024 Erik Ben Heckman, shared under the GPL-3.0 license
# except where otherwise noted
# <https://github.com/heckman/photos-server>

##
##  photos-http-handler
##  version 0.4

# With a URL path as an argument, will open the corresponding
# media item in Apple Photos. Without arguments, expects a valid
# HTTP request on stdin, and the media item corresponding to the
# requessted URL will be delivered via stdout as an HTTP response.

# The media item is selected using the first component of the URL path
# as an identifier. The identifier will first be used as a UUID. If that
# fails, it will be used as a seach query, after substituting all plus
# (`+`) tilde (`~`) and period (`.`) characters with spaces. If more
# than one media item is found, a random one will be selected.

# Three known error codes:
#   104: request to Photos timed out (TIMEOUT NOT IMPLEMENTED)
#   102: failed to read exported file (likely a PHOTOS ERROR)
#   100: failed to create temporary directory (SYSTEM ERROR)

## This file is named `Photos Server` so that's how it will appear
## in the notification center's warning about background tasks.
##
## It might still appear as `sh` for permission to access photos
## though. I'm having difficulty reproducing this.

set -eu

LOGGER_TAG=ca.heckman.PhotoServer.handler
TEMP_TEMPLATE=ca.heckman.PhotoServer.exported-media-item
TEMP_DIR=

# EITHER OPENS A MEDIA ITEM IN PHOTOS, if $1 is set,
# OR RESPONDS WITH AN IMAGE TO A HTTP REQUEST via stdin/stdout
#
# $1: optional raw encoded url path to open, otherwise
# &1< raw HTTP request
main(){
	if test $# -eq 0
	then handle_http_request
	else open_url "$1"
	fi
}

# OPENS A MEDIA ITEM IN PHOTOS
# EXITS 0 on success, 1 on failure
# $1: raw encoded url path
open_url(){
	if basename="$(open_media_item "$1")"
	then
		log info "Opened item: $basename"
		exit 0
	else
		log notice "Failed to open item for: $1"
		exit 1
	fi
}

# PRINTS HTTP response
# EXITS
# &1< HTTP request
handle_http_request(){
	read -r _ path _  # GET <PATH> HTTP/1.1
	log info "Request: $path"
	TEMP_DIR="$(mktemp -d -t $TEMP_TEMPLATE)" || die NO_TEMP
	trap 'cleanup $?' EXIT
	basename="$(export_media_item "$path" "$TEMP_DIR")" || die NO_MATCH
	filename="$(the_file_in "$TEMP_DIR")" || die NO_EXPORT
	serve_file "$filename" "$basename"
	exit 0
}

# PRINTS HTTP response
# $1: absolute path to file
# $2: basename for content returned
serve_file(){
	log info "Serving: $1"
	printf 'HTTP/1.1 200 OK\r\n'
	printf 'Connection: close\r\n'
	printf 'Content-Type: %s\r\n' "$(file -b --mime-type "$1")"
	printf 'Content-Length: %d\r\n' "$(stat -f'%z' "$1")"
	printf 'Content-Disposition: inline; filename=%s\r\n' "$2.${1##*.}"
	printf '\r\n'
	cat "$1";
}

# PRINTS absolute path to a file in the directory
# [0] if successful; [1] if not
# $1: absolute path to a directory
the_file_in(){
	find "$1" -maxdepth 1 -type f ! -name '.*' 2>/dev/null |
	grep -F ''
}

# EXPORTS file to temporary directory
# PRINTS basename of found media item
# [0] if successful; [1] if not
# $1: raw encoded url path
# $2: temporary directory, cannot contain ' character or other weirdness
export_media_item(){
	jxa "$1" "photos.export([item],{to:Path('${2}'),usingOriginals:false});" |
	grep .
}

# OPENS media item in Photos application
# PRINTS basename of found media item
# [0] if successful; [1] if not
# $1: raw encoded url path
open_media_item(){
	jxa "$1" 'photos.spotlight(item);photos.activate()' |
	grep .
}


# >&1 basename if search successful; nothing otherwise
# $1: raw encoded url path
# $2: jxa callback body of function(item)
jxa(){
	{
		{
			osascript -l JavaScript <<-EOF
const photos = Application("Photos");
const decodeQuery = (identifier) => identifier?.replace(/[+.~]/g, " ");

function withIdentifier(identifier, callback) {
	try {
		const item = photos.mediaItems.byId(identifier);
		callback(item);
		console.log("Selected by UUID: " + identifier);
		return true;
	} catch {
		try {
			const query = decodeQuery(identifier);
			const items = photos.search({ for: query });
			if (!items.length) return false;
			callback(items[Math.floor(Math.random() * items.length)]);
			console.log("Found with query: " + query);
			return true;
		} catch {
			return false;
		}
	}
}
const pathParts="${1}"?.split("/");
const identifier=pathParts?.at(1);
console.log("Identifier: " + identifier);
if ( identifier
	&& withIdentifier(identifier, (item) => { ${2} })
	&& (basename = pathParts?.at(-1) || pathParts?.at(-2))
)
	decodeURIComponent(basename);
			EOF
		} 2>&1 1>&3 |
		while IFS= read -r message
		do log debug "$message"
		done
	} 3>&1
}

# LOG ERROR, RETURN ERR RESPONSE, THEN CLEAN UP
# $1: enum
# $2: exit code if unknown error
die(){
	case "$1" in
	NO_MATCH)
		log "notice" "No matching media item found."
		err 404
		cleanup 0 0;; # exit status 0, not a server error.
	NO_TIME)
		log "err" "Request to Photos timed out."
		err 504
		cleanup 0 104;;
	NO_EXPORT)
		log "err" "Failed to read exported file."
		err 502
		cleanup 0 102;;
	NO_TEMP)
		log "alert" "Failed to create temporary directory."
		err 500
		cleanup 0 100;;
	*)
		log "alert" "Uncaught error: $1"
		err 500
		cleanup 0 "$1"
	esac
}


# WRITES TO SYSTEM LOGGER
#  0: on success
# $1: debug | info | notice | err | alert
# $2: message
log(){ logger -s -p "user.$1" "[$LOGGER_TAG] $2"; }
# log(){ echo "[$1] $2">&2;}


# PRINT NOT-OK HTTP RESPONSE
# $1: http error code to respond with
err(){
	case "$1" in
	404) svg "404 Not Found" "$missing_svg" "404_missing" ;;
	500) svg "500 Internal Server Error" "$error_svg" "500_error";;
	502) svg "502 Bad Gateway" "$missing_svg" "502_gateway";;
	504) svg "504 Gateway Timeout" "$timeout_svg" "504_timeout"
	esac
}

# REMOVE TEMPORARY DIRECTORY AND EXIT, catching UNKNOWN ERRORS
# $1: non-0 means it was caught by the trap on non-0 exit
# $2: exit code for known error when calling cleanup directly
# shellcheck disable=SC2329  # called from a trap
cleanup(){
	trap - EXIT
	! test -d "$TEMP_DIR" || rm -rf "$TEMP_DIR"
	test "$1" -eq 0 || die "$1"
	exit "${2:-0}"
}

# PRINT SVG  HTTP RESPONSE
# $1: http error code to respond with
# $2: svg data string
# $3: filename for content
svg(){
	printf 'HTTP/1.1 %s\r\n' "$1"
	printf 'Connection: close\r\n'
	printf 'Content-Type: image/svg+xml\r\n'
	printf 'Content-Length: %d\r\n' "${#2}"
	printf 'Content-Disposition: inline; filename=%s.svg\r\n' "$3"
	printf '\r\n%s' "$2"
}

missing_svg='<?xml version="1.0" encoding="UTF-8"?>
<!-- old school pixellated netscape broken image icon -->
<!--
  icon created for Netscape Navigator by Marsh Chamberlin (https://dataglyph.com)
  SVG hand-coded by github user diachedelic (https://gist.github.com/diachedelic)
  source: https://gist.github.com/diachedelic/cbb7fdd2271afa52435b7d4185e6a4ad
  accessed: 2024-02-12
-->
<svg viewBox="0 0 14 16" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <g id="borders-and-backgrounds">
    <path d="M0,0 L10,0 L10,1 L1,1 L1,15 L2,15 L2,16 L0,16 Z" fill="black"></path>
    <path d="M10,4 l4,0 l0,3 l-1,0 l0,-2 l-3,0 Z" fill="black"></path>
    <path d="M14,16 l0,-6 l-1,0 l0,5 l-5,0 l0,1 Z" fill="black"></path>
    <path d="M12,14 l0,-3 l-1,0 l0,2 l-2,0 l0,1 Z" fill="#bcbcc3"></path>
    <path d="M10,0 l1,0 l0,1 l1,0 l0,1 l1,0 l0,1 l1,0 l0,1 l-1,0 l0,-1 l-1,0 l0,-1 l-1,0 l0,2 l-1,0 Z" fill="#878787">
    </path>
    <path d="M2,2 l8,0 l0,3 l2,0 l0,2 l-4,0 l0,5 l-2,0 l0,1 l-2,0 l0,1 l-2,0 Z" fill="#bcbcc3"></path>
  </g>
  <g id="lefteye">
    <path d="M5,3 l2,0 l0,3 l-3,0 l0,-2 l1,0 l0,1 l1,0 l0,-1 l-1,0 Z" fill="#00891e"></path>
    <path d="M5,4 l1,0 l0,1 l-1,0 Z" fill="#00f248"></path>
    <path d="M7,4 l1,0 l0,2 l-1,0 l0,1 l-2,0 l0,-1 l2,0 Z" fill="black"></path>
  </g>
  <g id="righteye">
    <path d="M8,7 l3,0 l0,2 l-1,0 l0,-1 l-1,0 l0,1 l1,0 l0,1 l-2,0 Z" fill="#0064fb"></path>
    <path d="M9,8 l1,0 l0,1 l-1,0 Z" fill="#00fbfe"></path>
    <path d="M10,9 l1,0 l0,1 l-1,0 Z" fill="#003293"></path>
    <path d="M11,7 l1,0 l0,2 l-1,0 Z" fill="black"></path>
    <path d="M8,10 l2,0 l0,1 l-2,0 Z" fill="black"></path>
  </g>
  <g id="mouth">
    <path d="M3,8 l1,0 l0,1 l1,0 l0,1 l1,0 l0,1 l1,0 l0,1 l-1,0 l0,-1 l-1,0 l0,-1 l-1,0 l0,-1 l-1,0 Z" fill="#ff3900">
    </path>
    <path d="M3,9 l1,0 l0,1 l1,0 l0,1 l1,0 l0,1 l-3,0 Z" fill="#f73ae1"></path>
    <path d="M3,12 l3,0 l0,1 l-3,0 Z" fill="black"></path>
  </g>
</svg>
'
error_svg='<?xml version="1.0" encoding="UTF-8"?>
<!--
The "Sad Mac" icon was created for Apple Inc. by Susan Kare https://kareprints.com
The SVG was hand-coded Erik Ben Heckman https://erik.heckman.ca
and can be found embedded in the code for https://github.com/heckman/photos-server
-->
<svg viewBox="0 0 37 37" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path id="mask" fill="#ffffff" d="
    M6,4 h25 v26 h-25 z M7,3 h23 v32 h-23 zM8,2 h 21 v 2 h-21 z"></path>
  <path id="lines" fill-rule="evenodd" fill="black" d="
    M6,4 h25 v26 h-25 z M7,3 h23 v32 h-23 z M8,2 h 21 v 2 h-21 z M8,31 h21 v 3 h-21 Z
    M10,5 h17 v16 h-17 z M9,6 h19 v14 h-19 Z
    M13,9 h1 v3 h-1 v-1 h3 v1 h-1 v-3 h1 v1 h-3 Z
    M21,9 h1 v3 h-1 v-1 h3 v1 h-1 v-3 h1 v1 h-3 Z
    M16,13 h1 v2 h2 v-2 h1 v1 h-4 Z
    M16,16 h5 v2 h3 v1 h-1 v-2 h-8 v 1 h 1 Z
    M9,26 h2 v1 h-2 Z
    M21,25 h6 v1 h-6 Z"></path>
</svg>
'
timeout_svg='<?xml version="1.0" encoding="UTF-8"?>
<!--
The "Watch" cursor was created for Apple Inc. by Susan Kare https://kareprints.com
The SVG was hand-coded Erik Ben Heckman https://erik.heckman.ca who added the exclaimation
point and can be found embedded in the code for https://github.com/heckman/photos-server
-->
<svg viewBox="-2 -6 30 30" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <rect id="face" x="5" y="5" width="8" height="8" fill="white" />
  <path id="watch" fill-rule="evenodd" fill="black" d="
    M 6 1 h 6 v 16 h -6 Z
    M 4 6 h 10 v 6 h -10 Z
    M 5 5 h 8 v 8 h -8 Z
    M 6 6 h 6 v 6 h -6 Z
    M 14 8 h 1 v 2 h -1 Z
    M 9 6 h 1 v 4 h -3 v -1 h 2 Z
  "></path>
  <path id="bang" fill-rule=" evenodd" fill="#eb161e" d="
    M 18 1 v16 h 3 v -4 h -3 v 1 h 3 v -13 Z
  "></path>"
</svg>'

main "$@"


