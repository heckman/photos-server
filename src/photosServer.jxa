ObjC.import("Foundation");
ObjC.import("unistd");
ObjC.import("AppKit");

// Preconditions:
//
//
//
//

const app = Application.currentApplication();
app.includeStandardAdditions = true;

const config = ((defaults) => {
	const d = $.NSUserDefaults.standardUserDefaults;
	// ensure all defaults have persistent values
	Object.keys(defaults).forEach((key) => {
		if (d.objectForKey(key).isNil())
			d.setObjectForKey($(defaults[key]), key);
	});
	return {
		get: (key) => d.objectForKey(key).js,
		set: (key, value) => d.setObjectForKey($(value), key),
	};
})(DEFAULTS);

const launchAgent = (() => {
	const bid = $.NSBundle.mainBundle.bundleIdentifier.js;
	const uid = $.getuid();
	const label = bid + ".listener";
	const logDir = `${app.pathTo("home folder")}/Library/Logs/${bid}`;
	const errLogPath = `${logDir}/http-handler-error.log`;
	const plistDir = `${app.pathTo("home folder")}/Library/LaunchAgents`;
	const plistPath = `${plistDir}/${label}.plist`;
	return {
		stop: function () {
			try {
				app.doShellScript(
					`launchctl bootout gui/${uid}/${label} 2>/dev/null`,
				);
				return true;
			} catch {
				return false;
			}
		},
		remove: function () {
			this.stop();
			app.doShellScript(`rm ${plistPath}`);
		},
		start: function () {
			try {
				app.doShellScript(
					`launchctl bootstrap gui/${uid} ${plistPath} 2>/dev/null`,
				);
				return true;
			} catch {
				return false;
			}
		},
		isInstalled: function () {
			try {
				app.doShellScript(`test -e ${plistPath}`);
				return true;
			} catch {
				return false;
			}
		},
		isRunning: function () {
			try {
				app.doShellScript(`
					set -o pipefail
					launchctl list | grep -Fq "${label}"
				`);
				return true;
			} catch {
				return false;
			}
		},
		getPort: function () {
			try {
				return app.doShellScript(
					`plutil -extract Sockets.Photos.SockServiceName raw ${plistPath}`,
				);
			} catch {
				return "0";
			}
		},
		save: function (port) {
			const plistJson = {
				Label: label,
				Program: HANDLER,
				RunAtLoad: false,
				Sockets: {
					Photos: {
						SockNodeName: "localhost",
						SockServiceName: port.toString(),
						SockPassive: true,
					},
				},
				inetdCompatibility: {
					Wait: false,
				},
				StandardErrorPath: errLogPath,
			};
			try {
				app.doShellScript(`
					set -o pipefail
					mkdir -p '${plistDir}' &&
					printf '%s' '${JSON.stringify(plistJson)}' |
					plutil -convert xml1 -o '${plistPath}' -
				`);
				this.stop();
				this.start();
				return true;
				app.displayAlert("Server updated.");
			} catch (e) {
				app.displayAlert("Error: " + e.message);
				return false;
			}
		},
	};
})();

function pause() {
	delay(0.2);
}

function primeModal() {
	const browser = config.get("browser");
	const origin = config.get("origin");
	const port = launchAgent.getPort();
	const redirections = app
		.doShellScript(
			`/Applications/Photos\\ Server.app/Contents/MacOS/redirections ${origin.replace(/^.*\/\//, "")}||:`,
		)
		.trim();
	const choices = {
		restart: { label: "Restart the server", action: portModal },
		remove: {
			label: "Remove the server",
			action: () => {
				launchAgent.remove();
				pause("Removing server");
				return true;
			},
		},
		start: { label: "Start the server", action: portModal },
		origin: {
			label: "Set URL prefix that will open in Photos",
			action: originModal,
		},
		browser: {
			label: "Set browser for everything else",
			action: browserModal,
		},
		redirections: {
			label: "Display configured redirections",
			action: () => redirectionsModal(redirections),
		},
		homepage: {
			label: "Visit Photos Server homepage and close",
			action: () => {
				app.displayAlert("Opening homepage...", {
					givingUpAfter: 1,
				});
				app.doShellScript(
					`open -a "${browser}" https://github.com/heckman/photos-server`,
				);
				return false;
			},
		},
	};

	let list = [];
	let status = "";
	if (launchAgent.isRunning()) {
		list = [choices.restart.label, choices.remove.label];
		status = "Serving photos on localhost:" + port;
	} else {
		list = [choices.start.label];
		status = launchAgent.isInstalled()
			? "Server is stopped."
			: "Server is not installed.";
	}
	status = `${status}


Links beginning with "${origin}"
will open in Photos.

Everything else will open in ${browser}.`;

	list = [...list, choices.origin.label, choices.browser.label];

	if (redirections) list = [...list, choices.redirections.label];

	list = [...list, choices.homepage.label];

	const choice = app.chooseFromList(list, {
		withTitle: "Photos Server Control",
		withPrompt: status,
		defaultItems: [],
		okButtonName: "Select",
		cancelButtonName: "Done",
		multipleSelectionsAllowed: false,
		emptySelectionAllowed: false,
	});
	if (choice === false) return;
	if (
		Object.values(choices)
			.find((c) => c.label === choice[0])
			.action()
	)
		primeModal();
}

function redirectionsModal(redirections) {
	app.displayAlert(
		redirections
			? "Configured redirections\n(Not necessarily enabled)"
			: "No redirections configured",
		{
			as: "informational",
			message: redirections,
		},
	);
	return true;
}
function originModal() {
	try {
		const origin = app.displayDialog(
			"URLs begining with this prefix will be opened in Photos.\n(http:// will pre prepended if the scheme is not entered here.)",
			{
				defaultAnswer: config.get("origin"),
				hiddenAnswer: false,
				buttons: ["Cancel", "OK"],
				defaultButton: "OK",
				cancelButton: "Cancel",
				withTitle: "Set origin",
			},
		);
		config.set(
			"origin",
			"http://" + origin.textReturned.replace(/^.*\//, ""),
		);
	} catch {
		// ignore error
	}
	return true;
}

function browserList() {
	const ws = $.NSWorkspace.sharedWorkspace;
	const appURLs = ws.URLsForApplicationsToOpenURL(
		$.NSURL.URLWithString($("https://apple.com")),
	);
	return appURLs.js
		.map((url) => {
			const name =
				$.NSFileManager.defaultManager.displayNameAtPath(
					url.path,
				);
			// Force a native JS string primitive
			return String(ObjC.unwrap(name));
		})
		.filter((name) => name !== "Photos Server");
}
function browserModal() {
	const browser = app.chooseFromList(browserList(), {
		withTitle: "Select Default Browser",
		withPrompt: "Pick one",
		defaultItems: [config.get("browser")],
		okButtonName: "Select",
		cancelButtonName: "Cancel",
		multipleSelectionsAllowed: false,
		emptySelectionAllowed: false,
	});
	if (browser !== false) {
		config.set("browser", String(browser[0]));
	}
	return true;
}
function validPort(port) {
	try {
		port = parseInt(port);
		return (
			port >= 1024 &&
			port <= 65535 &&
			port != 5000 &&
			port != 7000
		);
	} catch {
		return false;
	}
}
function portModal(errorMessage = "Select the port") {
	try {
		const port = app.displayDialog(errorMessage, {
			defaultAnswer: config.get("port"),
			hiddenAnswer: false,
			buttons: ["Cancel", "OK"],
			defaultButton: "OK",
			cancelButton: "Cancel",
			withTitle: launchAgent.isRunning()
				? "Restart Server"
				: "Start Server",
		});
		if (port.buttonReturned === "OK") {
			if (validPort(port.textReturned)) {
				config.set("port", port.textReturned);
				launchAgent.save(port.textReturned);
				pause("Starting server");
			} else {
				portModal(`${port.textReturned} is an invalid port.`);
			}
		}
	} catch {
		//
	}
	return true;
}
function run() {
	primeModal();
}

function GURLGURL(url) {
	const origin = config.get("origin");
	if (url.startsWith(origin)) {
		const urlPath = url.substring(origin.length);
		app.doShellScript(`'${HANDLER}' '${urlPath}'`);
	} else {
		app.doShellScript(`open -a "${config.get("browser")}" ${url}`);
	}
	return true;
}
