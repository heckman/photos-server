#!/bin/dash
# Copyright (c) 2024 Erik Ben Heckman, shared under the GPL-3.0 license
# except where otherwise noted
# <https://github.com/heckman/photos-server>


# photos-server-serverctl


COMMAND=serverctl
VERSION=0.4

HOMEPAGE=https://github.com/heckman/photos-server
APP_BID=ca.heckman.PhotosServer
# appdended to the bundle identifier for launch agent and launch daemon
LAUNCH_AGENT_SUFFIX=.listener
LAUNCH_DAEMON_SUFFIX=.port-forwarding
# paths relative to the bundle's Resources folder
HTTP_HANDLER_RESOURCE='Scripts/Photos Server'
FALLBACK_DEFAULTS_RESOURCE='defaults.plist'
ICON_RESOURCE='AppIcon.icns'

# only use standard commands
PATH='/usr/bin:/bin'

# it is crucial we exit on errors and unset variables
set -o errexit -o nounset

SELF="$(realpath "$0")"
# the rest of these constants are have calculated values
RESOURCES="$(dirname "$SELF")/.."
HTTP_HANDLER="$RESOURCES/$HTTP_HANDLER_RESOURCE"
DEFAULT_SETTINGS_PLIST="$RESOURCES/$FALLBACK_DEFAULTS_RESOURCE"
ICON_PATH="$RESOURCES/$ICON_RESOURCE"

LAUNCH_AGENT_DIR="$HOME/Library/LaunchAgents"
LAUNCH_AGENT_LABEL="$APP_BID$LAUNCH_AGENT_SUFFIX"
LAUNCH_AGENT_PLIST="$LAUNCH_AGENT_DIR/$LAUNCH_AGENT_LABEL.plist"

FORWARDING_DAEMON="$APP_BID$LAUNCH_DAEMON_SUFFIX"

usage() {
	echo "
Usage: $COMMAND start [port]
       $COMMAND [stop|status|port|test]
       $COMMAND defaults [origin|browser|port] [VALUE]

Controls the server and settings for the Photos Server application.

Commands:

    start [port]  If the server is already running, restarts it, otherwise,
                  installs a startup item to the User's Library, and starts
                  the server. If a port is specified, it must be an integer
                  between 1024 and 65535 and it must not be 5000 or 7000. The
                  port setting will be saved in the User's preferences, whence
                  it will be read if the port is not specified.

    stop          Stops the server, and uninstalls the startup item.

    status        Prints whether the server is running, and on which port.

    port          Prints the port the server is listening on.

    test          Tests whether the server is running. Returns a non-zero exit
                  code if the server is not running. Produces no output.

    dialog        Open a GUI dialog control panel.

    forwarding    Print port forwarding rules configured by the optional launch
                  daemon. The rules are not neccessarily active. IP addresses
		  will be replaced with their last corresponding hostname in
		  /etc/hosts, if any. If there are no configure rules, no output
		  will be produced. In any case, exit status is 0.

    browsers      Lists the applications suitable for using as the preferred
                  handler for opening HTTP URLs, as a json array.

    defaults      Prints the current values of the settings, in json format.

    defaults [origin|browser|port]

                  Prints the current value of the specified setting.

    defaults [origin|browser|port] VALUE

                  Sets the default value for the specified setting. Note that
                  the port value will not be used until the next time the server
                  is started. The other two settings are effective immediately.

		  Note that when the origin in set, it will be given a scheme of
		  http://, in place of any that may have been provided.

		  Unsuitable values will be rejected with a non-zero exit code.
"
}
version() {
	echo "$COMMAND v$VERSION"
}
main() {
	case "${1-}" in
	-h|-help|--help|help) usage;;
	-v|-version|--version|version) version;;
	start|restart|enable|install)
		enable_server "${2-}"
		;;
	stop|remove|disable|uninstall)
		disable_server
		;;
	port)
		get_port
		;;
	test|is-running)
		is_server_running
		;;
	status|'')
		print_status
		;;
	default|defaults)
		case "${2-}" in
		'') get_defaults;;
		browser|origin|port)
			if test -z "${3-}"
			then get_default "$2"
			else set_default "$2" "$3"
			fi
			;;
		*) err USAGE "Invalid default argument: $2";;
		esac
		;;
	redirections|forwarding)
		print_forwarding
		;;
	browsers)
		valid_browsers
		;;
	dialog|gui)
		primeModal
		;;
	function)
		shift
		if type "${1-}" | grep -qF 'function'
		then "$@"
		else err USAGE "Unknown function: $1"
		fi
		;;
	*)
		err USAGE "Unknown command: $1"
		;;
	esac
}
enable_server(){
	local port=
	test -z "${1-}" || port="$(validate_port "$1")"
	if is_server_running
	then
		echo "Restarting Photos Server..."
		stop_server
	else
		echo "Starting Photos Server..."
	fi
	install_launch_agent "$port"
	start_server
	echo "Photos Server started on port $(get_port)"
}
disable_server(){
	if is_server_running
	then
		echo "Stopping Photos Server..."
		stop_server
	else
		echo "Photos Server is not running."
	fi
	if is_launch_agent_installed
	then
		echo "Removing launch agent..."
		remove_launch_agent
		echo "Launch agent has been removed."
	else
		echo "Launch agent is not installed."
	fi
}
err() {
	case "$1" in
	USAGE)
		echo "$2"
		return 2;;
	PORT_NOT_SET) echo "Port number not set."
		return 72;;
	PORT_NOT_NUMBER) echo "'$2' is an invalid port number; it must be a positive integer."
		return 73;;
	PORT_TOO_HIGH) echo "Port $2 is too high. It must be between 1024 and 65535."
		return 74;;
	PORT_TOO_LOW) echo "Port $2 is too low. It must be between 1024 and 65535."
		return 75;;
	PORT_RESERVED) echo "Sorry, port $2 is reserved."
		return 76;;
	CANT_MKDIR) echo "Could not create directory: $2"
		return 77;;
	CANT_WRITE_PLIST) echo "Could not write plist: $2"
		return 78;;
	CANT_READ_DEFAULTS) echo "Could not get default for $2"
		return 79;;
	CANT_WRITE_DEFAULTS) echo "Could not set default for $2 to $3"
		return 80;;
	CANT_REMOVE_LAUNCH_AGENT) echo "Could not remove launch agent"
		return 81;;
	CANT_START_SERVER) echo "Could not start server"
		return 82;;
	CANT_STOP_SERVER) echo "Could not stop server"
		return 83;;
	NOT_RUNNING) echo "Photos Server is not running."
		return 84;;
	LAUNCH_AGENT_NOT_INSTALLED) echo "Launch agent is not installed."
		return 85;;
	ALREADY_RUNNING) echo "Photos Server is already running."
		return 86;;
	INVALID_ORIGIN) echo "'$2' is not a valid origin."
		return 87;;
	INVALID_BROWSER) echo "'$2' is not registered to handle HTTP URLs. Valid applictions: $3."
		return 88;;
	*) echo "Unknown error: $1"
		return "$1";;
	esac >&2;
}
pause() {
	:
}
print_status() {
	if is_server_running
	then echo "Server is running on port $(get_port)"
	elif is_launch_agent_installed
	then echo "Server is installed, but not running."
	else echo "Server is not installed."
	fi
}
validate_port() { local port="$1"
	test -n "$port" || err PORT_NOT_SET
	case "$port" in *[!0-9]*)
		err PORT_NOT_NUMBER "$port";;
	esac
	test "$port" -le 65535 || err PORT_TOO_HIGH "$port"
	test "$port" -ge 1024 || err PORT_TOO_LOW "$port"
	test "$port" -ne 5000 -a "$port" -ne 7000 || err PORT_RESERVED "$port"
	echo "${port#"${port%%[!0]*}"}" # remove leading zeros
}
write_launch_agent_plist(){ local port="$1"
	mkdir -p "$LAUNCH_AGENT_DIR" || err CANT_MKDIR "$LAUNCH_AGENT_DIR"
	{
		plutil -convert xml1 -o "$LAUNCH_AGENT_PLIST" - <<-EOF
		{
			Label: "${LAUNCH_AGENT_LABEL}",
			Program: "${HTTP_HANDLER}",
			RunAtLoad: false,
			Sockets: {
				Photos: {
					SockNodeName: "localhost",
					SockServiceName: ${port},
					SockPassive: true,
				},
			},
			inetdCompatibility: {
				Wait: false,
			},
		}
		EOF
	} || err CANT_WRITE_PLIST "$LAUNCH_AGENT_PLIST"
}
install_launch_agent(){ local port="$1"
	if test -n "$port"
	then
		write_launch_agent_plist "$port"
		defaults write "$APP_BID" port "$port" 2>/dev/null ||
			err CANT_WRITE_DEFAULTS port "$port"
	else
		port="$(get_default port | grep .)" ||
			err CANT_READ_DEFAULTS port
		validate_port "$port" # just in case a bad value got in somehow
		write_launch_agent_plist "$port"
	fi
}
remove_launch_agent(){
	rm "$LAUNCH_AGENT_PLIST" ||
		err CANT_REMOVE_LAUNCH_AGENT
}
start_server() {
	is_launch_agent_installed || err LAUNCH_AGENT_NOT_INSTALLED
	! is_server_running || err ALREADY_RUNNING
	launchctl bootstrap "gui/$(id -u)" "${LAUNCH_AGENT_PLIST}" ||
		err CANT_START_SERVER
	pause
	is_server_running || err CANT_START_SERVER
}
stop_server() {
	is_server_running || err NOT_RUNNING
	launchctl bootout "gui/$(id -u)/${LAUNCH_AGENT_LABEL}" ||
		err CANT_STOP_SERVER
	pause
	! is_server_running || err CANT_STOP_SERVER
}
is_launch_agent_installed() {
	test -e "${LAUNCH_AGENT_PLIST}"
}
is_server_running() {
	launchctl list |
	awk -v id="$LAUNCH_AGENT_LABEL" '$3==id{f=1;exit}END{exit !f}'
}
get_port() {
	if is_launch_agent_installed
	then plutil -extract Sockets.Photos.SockServiceName raw "${LAUNCH_AGENT_PLIST}"
	fi
}
get_defaults() {
	defaults read "$APP_BID" 2>/dev/null ||
	plutil -convert json -o - "${DEFAULT_SETTINGS_PLIST}"
}
get_default() { local default="$1"
	defaults read "$APP_BID" "$default" 2>/dev/null ||
	plutil -extract "$default" raw "${DEFAULT_SETTINGS_PLIST}"
}
set_default() { local default="$1" value="$2"
	case "$default" in
	browser) value="$(validate_browser "$value")";;
	origin) value="$(validate_origin "$value")";;
	port) value="$(validate_port "$value")";;
	esac
	defaults write "$APP_BID" "$default" "$value" 2>/dev/null ||
		err CANT_WRITE_DEFAULTS "$default" "$value"
}
validate_origin() { local origin="${1#*://}" # strip scheme
	case "$origin" in
	*[!a-zA-Z0-9.:-]*|*:*[!0-9]) err INVALID_ORIGIN "$1";;
	esac
	echo "http://$origin"

}
valid_browsers() {
	# shellcheck disable=SC2016  # the jxa script must not suffer expansion
	osascript -ss -l JavaScript -e 'ObjC.import("AppKit");
        const appURLs =
                $.NSWorkspace.sharedWorkspace.URLsForApplicationsToOpenURL(
                        $.NSURL.URLWithString($("https://apple.com")),
                );
        appURLs.js
                .map((url) => {
                        const name =
                                $.NSFileManager.defaultManager.displayNameAtPath(
                                        url.path,
                                );
                        // Force a native JS string primitive
                        return String(ObjC.unwrap(name));
                })
                .filter((name) => name !== "Photos Server");
'
}
validate_browser() { local browser="$1"
	local valid_browsers_list
	valid_browsers_list="$(valid_browsers)"
	case "$valid_browsers_list" in
	*'"'"$browser"'"'*)
		echo "$browser";;
	*)
		err INVALID_BROWSER "$1" "$(echo "$valid_browsers_list" |
		tr -d ']"[')";;
	esac
}
print_forwarding(){
	test -f "/Library/LaunchDaemons/$FORWARDING_DAEMON.plist" || return
	# shellcheck disable=SC2046  # subshell output splits on whitespace
	# shellcheck disable=SC2183  # command expansion splits into 4 words
	printf "IP4:  %s ðŸ ª %s\nIP6:  %s ðŸ ª %s\n" $(
		launchctl print "system/$FORWARDING_DAEMON" |
		grep -- '->' |
		sed -E 's/^.* ([0-9.]+) port ([0-9]+) -> ([0-9.]+) port ([0-9]+)\\.* ([a-fA-F0-9:]+) port ([0-9]+) -> ([a-fA-F0-9:]+) port ([0-9]+)\\.*$/\1:\2 \3:\4 \5:\6 \7:\8/;' |
		awk 'FNR==NR { hosts[$1]=$2; next } { for (ip in hosts) gsub(ip, hosts[ip]) } 1' /etc/hosts -
	)

}
selfcheck_err_codes() {
	# this self-check doesn't respect comments
	awk '
		/^err()/,/^}/{
			if(/^[[:space:]]*[A-Z_]+\)/) {
				sub(/\)/,"")
				defined[$1]=1
				unused[$1]=1
			}
		}
		match($0,/err [A-Z_]+/){
			$0=(substr($0,RSTART))
			used[$2]=$0
		}
		END{
			for(err in used)
				if(!defined[err])missing[err]=1
				else delete unused[err]
			for(err in unused)print("unused: "err)
			for(err in missing)print("undefined: "err)
		}
	' "$SELF" | grep . && return 1 || return 0
}


jxa() { local script="$1"; shift # remainder are script args
	osascript -sh -l JavaScript -e "
const app = Application('System Events');app.includeStandardAdditions = true;app.activate();
//	const app = Application.currentApplication();app.includeStandardAdditions = true;
$script" -- "$@"
}
dialogBox() { local message="$1" options="${2+", $2"}"
	jxa "function run(args){returned=app.displayDialog(args[0]$options);return returned.textReturned}" "$message"
}
# reads list of choices from stdin
choiceBox() { local options="${1+", $1"}"
	local arg
	set --
	while IFS= read -r arg
	do set -- "$@" "$arg"
	done
	jxa "function run(list){return app.chooseFromList(list$options)[0]}" "$@" |
	grep .
}
infoBox() { local message="$1" timeout="${2:-0}"
	dialogBox "$message" '{
		withTitle: "Photos Server",
		withIcon: Path("'"$ICON_PATH"'"),
		givingUpAfter: '"$timeout"',
		buttons: ["Dismiss"],
		defaultButton: "Dismiss",
	}'
}
pauseBox() { local message="$1"
	infoBox "$message" 1.5
}
primeModal() {
	local choice options status
	local choices='
on	portModal	Change the port
on	disableNotice	Disable the server
off	portModal	Enable the server
both	browserModal	Set browser for everything else
both	forwardsModal	Display configured port forwarding

both	visitNotice	Visit Photos Server homepage
'
	status='`'"$(print_status)

Links beginning with $(get_default origin)
will open in Photos.

Everything else will open in $(get_default browser)."'`'

	options='{
		withTitle:"Photos Server Control",
		withPrompt:'"$status"',
		okButtonName: "Select",
		cancelButtonName: "Done"
	}'

	choice="$(echo "$choices" |
	awk -F'\t' '
		/^'"$(
			is_server_running && echo on || echo off
		)"'|both/{
			print $3
		}
	' | choiceBox "$options")" || exit 0

	eval "$(echo "$choices" |
	awk -v choice="$choice" -F'\t' '$NF==choice{print $2}')"

	primeModal
}
disableNotice(){
	disable_server
	infoBox "Disabling server" 1.5
}
visitNotice(){
	infoBox "Opening Photos Server homepage..." 1.5
	open "$HOMEPAGE"
}
forwardsModal() {
	local forwarding
	infoBox "$(
		if forwarding="$(print_forwarding | grep .)"
		then printf "These redirections are configured, but not necessarily enabled.\n\n%s" "$forwarding"
		else printf "No redirections configured"
		fi
	)"
}
portModal() { local errorMessage="${1:-Select the port}"
	local port
	port="$(dialogBox "$errorMessage" '{
		defaultAnswer: "'"$(get_default port)"'",
		buttons: ["Cancel", "OK"],
		defaultButton: "OK",
		cancelButton: "Cancel",
		withTitle: "'"$(
			is_server_running &&
			echo "Photos Server: Change Listening Port" ||
			echo "Photos Server: Enable Server")"'"
	}')"
	if message="$(validate_port "$port" 2>&1)"
	then
		enable_server "$port"
	else
		portModal "$message"
	fi
}
browserModal() {
	local browser
	if browser="$(
		valid_browsers |
		awk 'BEGIN{RS=", "}{gsub(/^\[?"|"]?[[:space:]]*$/,"");print}' |
		choiceBox '{
			withTitle: "Photos Server Preferences",
			withPrompt: "Select Default Browser",
			defaultItems: ["'"$(
				get_default browser
			)"'"],
			okButtonName: "Select",
			cancelButtonName: "Cancel",
			multipleSelectionsAllowed: false,
			emptySelectionAllowed: false,
		}'
	)"
	then set_default browser "$browser"
	fi
}

originModal() { local errorMessage="${1+"$1

"}"
	errorMessage="${errorMessage}URLs begining with this prefix will be opened in Photos.
(http:// will pre prepended if the scheme is not entered here.)"
	local origin
	origin="$(dialogBox "$errorMessage" '{
		defaultAnswer: "'"$(get_default origin)"'",
		buttons: ["Cancel", "OK"],
		defaultButton: "OK",
		cancelButton: "Cancel",
		withTitle: "Photos Server: Set Origin"
	}')"
	if origin="$(validate_origin "$origin" 2>&1)"
	then
		set_default origin "$origin"
	else
		originModal "$origin"
	fi

}


main "$@"

