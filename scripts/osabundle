#!/usr/bin/env bash


readonly usage="Usage: $0 <config> [target] [script]"

# dependencies

png2icns=$(cd -- "$(dirname "$0")" >/dev/null 2>&1 && pwd)/png2icns


set -euo pipefail

# paths to config file and target file
declare config target

# paths specified in the config are relative to the config file
# unless they start with a / in which case they relative to the
# git repository root.
declare config_dir repo_root
repo_root="$(git rev-parse --show-toplevel)"

# set to a non-empty string to use as a temporary directory
# for intermediate files, otherwise a system temporary directory
# will be used and cleaned up on exit
declare temp_dir="$repo_root/temp"


readonly -A errors=(
	[TOO_MANY_ARGS]='2:Too many command-line arguments.'
	[DEFAULT]='20:%s'
	[NO_CONFIG_FILE]='21:Config file not found: %s'
	[NO_CONFIG_FILE]='21:Config file not found: %s'
	[NO_NAME]='22:No name specified.'
	[NO_TARGET]='23:No target specified.'
	[CANT_MAKE_TARGET_DIR]='24:Cannot create target directory: %s'
	[NO_SCRIPT]='25:No script file specified.'
	[SCRIPT_NOT_FOUND]='26:Script file not found: %s'
	[BAD_SCRIPT_EXTENSION]='27:Unknown script extension: %s'
	[CANT_COMPILE_SCRIPT]='28:Cannot compile osascript: %s'
	[CANT_COPY_CONTENTS]='29:Cannot copy contents: %s'
	[PLIST_NOT_FOUND]='30:Plist not found: %s'
	[CANT_MODIFY_PLIST]='31:Cannot create plist'
	[CANT_COMPILE_ICON]='32:Cannot compile icon: %s'
	[BAD_LEGACY_ICON_EXTENSION]='33:Unknown legacy icon extension: %s'
	[CANT_GENERATE_ICNS]='34:Cannot generate icns: %s'
)

main(){
	local config_file script_file
	case "$#" in
		3) script_file="$3" ;&
		2) target="$2" ;&
		1) config_file="$1" ;;
		*) return "$(err TOO_MANY_ARGS)" ;;
	esac

	[[ -f "$config_file" ]] ||
		return "$(err NO_CONFIG_FILE "$config_file")"

	config="$(cat "$config_file")"
	config_dir="$(dirname "$config_file")"


	[[ -n ${target:-} ]] ||
		target="$(get_path .target)" ||
		return "$(err NO_TARGET)"

	local target_dir
	case "$target" in
	*.app|*.scpt)
		target_dir="$(dirname "$target")"
		;;
	*)
		# target should be the directory to put the bundle in
		local basename
		basename="$(get_prop .name)" || return "$(err NO_NAME)"
		target_dir="$target"
		target="$target_dir/$basename.app"
		;;
	esac
	mkdir -p "$target_dir" ||
		return "$(err CANT_MAKE_TARGET_DIR "$target_dir")"

	compile_script "${script_file:-}" || return


	## the remainder only applies to app bundles
	[[ "$target" == *.app ]] || return 0

	copy_contents || return
	write_to_plist || return
	generate_icons || return

	codesign --force --deep --sign - "$target"
	return 0
}
# merge the contents of source contents into target conents
copy_contents(){
	local contents
	if contents="$(get_path .contents)"
	then
		ditto "$contents" "$target/Contents" ||
			return "$(err CANT_COPY_CONTENTS "$contents")"
	fi
}
# generate tahoe and/or legacy icons
generate_icons(){
	local tahoe_icon legacy_icon

	if tahoe_icon="$(get_path .icon)"
	then
		xcrun actool \
			"$tahoe_icon" \
			--compile "$target/Contents/Resources" \
			--platform macosx \
			--target-device mac \
			--minimum-deployment-target 16.0 \
			--include-all-app-icons \
			--output-partial-info-plist /dev/null >/dev/null ||
			return "$(err CANT_COMPILE_ICON "$tahoe_icon")"
		plutil \
			-replace CFBundleIconName \
			-string "$(basename "$tahoe_icon" .icon)" \
			"$target/Contents/Info.plist"
	fi


	if legacy_icon="$(get_path .legacyIcon)"
	then
		case "${legacy_icon##*.}" in
		icns) cp \
			"$legacy_icon" \
			"$target/Contents/Resources/AppIcon.icns" ;;
		png)  "$png2icns" \
			--temp "$temp_dir" \
			"$legacy_icon" \
			"$target/Contents/Resources/AppIcon.icns" ||
			return "$(err \
				CANT_GENERATE_ICNS \
				"$legacy_icon"
			)" ;;
		*) return "$(err \
				BAD_LEGACY_ICON_EXTENSION \
				"${legacy_icon##*.}"
			)" ;;
		esac
		plutil \
			-replace CFBundleIconFile \
			-string "AppIcon" \
			"$target/Contents/Info.plist"
		rm "$target/Contents/Resources/applet.icns"

	fi
}

compile_script(){ local script_file="$1"

	[[ -n $script_file ]] ||
		 script_file="$(get_path .entry)" || return "$(err NO_SCRIPT)"
	[[ -f "$script_file" ]] ||
		return "$(err SCRIPT_NOT_FOUND "$script_file")"


	local osa_language
	case "${script_file##*.}" in
	jxa|js) osa_language=JavaScript ;;
	applescript) osa_language=AppleScript ;;
	*) return "$(err BAD_SCRIPT_EXTENSION "${script_file##*.}")"
	esac

	cat <(
		jq -r '
			select(has("settings")) |
			"const settings=\(.settings|@json);\n"
		' <<<"$config"
	) <(get_prop .prescript[]) "$script_file" |
	osacompile -l "$osa_language" -o "$target" ||
		return "$(err CANT_COMPILE_SCRIPT "$script_file")"
}

# print the default plist generated by soacompile as json
print_plist_as_json(){ local plist="$1"
	[[ -f "$plist" ]] || return "$(err PLIST_NOT_FOUND "$plist")"
	plutil -convert json -o - "$plist"
}

write_to_plist(){
	local plist="$target/Contents/Info.plist"

	jq --argjson map '
{
	"name": "CFBundleName",
	"identifier": "CFBundleIdentifier",
	"version": "CFBundleShortVersionString",
	"copyright": "NSHumanReadableCopyright",
	"shortName": "CFBundleName",
	"shortVersion": "CFBundleShortVersionString",
	"longVersion": "CFBundleVersion"
}
' '
((input) * (.plist // {})) * (
    with_entries(select(.key | in($map)) | .key = $map[.key])
)
' - <(print_plist_as_json "$plist") <<<"$config" |
plutil -convert xml1 -o "$plist" - ||
	return "$(err CANT_MODIFY_PLIST "$plist")"

}

get_prop(){  local property=".${1#.}"
	jq -r "$property // empty" <<<"$config" 2>/dev/null | grep -F ''
}

get_path(){ local property="$1"
	local path
	path="$(get_prop "$property")" || return
	if [[ $path == /* ]]
	then echo "${repo_root}${path}"
	else echo "${config_dir}/${path}"
	fi
}


# prints a formatted error message to stderr
# and an error code to stdout
#
err(){
	local error="${errors[$1]}"
	if [[ -n ${errors[$1]} ]]
	then shift
	else error="${errors[DEFAULT]}"
	fi
	# shellcheck disable=SC2059  # variable format
	printf "Error: ${error#*:}" "$@" >&2
	echo "${error%%:*}"
}
debug(){ echo "$@" >&2; }

main "$@"
